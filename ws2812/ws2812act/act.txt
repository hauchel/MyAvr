Progrämmsche für Effekte auf 256 LEDs mit ATMega 328
zur Ablaufgestaltung  Terminal erforderlich
zur Ausführung reicht RC5 Fernbedienung 

Ablauf: rudimentärer Code zu Ablaufsteuerung
Stark gewöhnungsbedürftig da reverse Notation, d.h erst Parameter dann Befehl.
Jeder Befehl ist nur ein Zeichen, das reduziert den Schreib/Speicheraufwand und trainiert das Hirn.


Register inp:
Das Register inp enthält int, gesetzt durch Ziffer,#,BS
0..9			inp <- inp*10 + Ziffer
#				inp <- inp+1
BS				inp <- inp/10
Das gilt solange bis andere Zeichen eingegeben werden. 
Space			dient als optischer Trenner, beendet Ziffernmodus sonst nix.
Beispiel:
98			; inp ist 98
98 2			; inp ist 2
7#			; inp ist 8

Nummerierung der Leds
gespeichert werden 256*3 GRBs so wie sie rausgeschoben werden.
Dummerweise ist Reihenfolge 0..7 15..8, d.h. arrpos() rechnet um 0 ist links unten

pix enhält RGB-Werte (0 bis 255), quasi Stiftfarbe 
r g b 			setzt diese Werte auf inp
R G B				setzt inp auf r oder g  oder b von pix
l	(LED) 		überträgt pix -> LED[inp] 
L				überträgt LED[inp] nach pix
f	(fill) 		füllt alle LEDs mit pix
z	(zero) 		füllt alle LEDs mit 0/0/0
Beachte, dass inp zwischen Befehlen erhalten bleibt, erst wenn wieder Ziffer oder # wird es geändert.
Beispiel:
z10r0gb4l#l##l		Löscht alle LEDs, 4,5,7 auf wenig rot
255rgbf			Fernlicht / Test Spannungsversorgung

10 verschiedene RGB Werte können im color-Array[0..9] abgelegt werden
c 				pix <- color(inp)
C				color(inp) <- pix
Beispiel:
30r0gb1C		; color 1 ist dunkles rot
1c8l			; LED 8 auf color 1

Nebenbei:
v (verbose)		toggelt 0 nix, 1 wait und update , 2 Trace
V    			toggle echo von erhaltenen Zeichen
CR				zeige wichtigste Infos:  ... Inp     7 Led   7 pix R 10 G  0 B 26  ...
?				(siehe unten) zeige alle stacks und den loop-Status, memo nur wenn != 0

Ein Ablauf ist eine Folge von Befehlen in dem Null-terminated String bef[] max len 127.
Diese werden im Flash oder im Arduino Sourcecode (befehle[]) gespeichert.
Technisch sind 0..39 (pgmbefM=40) fest programmiert in myBefs.h, 40.. in Flash 40-> Page 1. Jeder Befehl wird in SPM_PAGESIZE = 128 byte abgelegt und ist weg wenn neu geflasht wird.
m (memory) 		bef <- Befs oder Flash-Page mit key inp 
w (write)		schreibe bef-> Flash mit key inp (nur für 40+)
bef kann auch über Serial eingelesen werden, das ist aber blocking bis CR.
" 			bef <- nachfolgende Eingaben bis CR
ein zweites " während der Eingabe führt den eingegbenen text sofort aus, d.h. einfacher Test kopiere aus Sourcecode "blabla"


Ablaufbefehle:
befN enthält die nummer des aktuellen Programms 0..39, 40..
befP zeigt auf den nächsten auszuführende Befehl (ab 0) in bef
X	(exec) 	 	führe bef ab 0 aus 
x				lies Flash mit key inp und führe aus (gosub)
y				lies z. B. Buchstabe[inp] von charbefehle[charbefM], pop (die Position) und (gosub)
q	(quit)		stop Execution (runMode 0),
Q				stop and reset stacks, befP
s	(single)	 	single step  (runMode 1)
k	(kontinue)  	beende single step oder nach stop
j  	(jump)    		springe zum #inp byte in bef
S	(Stack)		zeige Stack
e				refresh display
refresh() passiert nur, wenn Programme beendet sind. Um es z.B. im single step modus zu erzwingen: e
aus charbef y dürfen keine Unterprogramme mit x oder y aufgerufen werden, da return-Adresse  nicht gemerkt wird. Es dürfen nur Aufrufe aus Programmen erfolgen, die im Flash stehen. 

Beispiel:
3x		;
3ms		; lade Ablauf 3 und starte single step
0~4,23,0U,s~c,1+~,32xu	Breakpoint nach push des aktuellen Schleifenwerts (U,s)


Agenten:
Um interessantere Effekte zu erhalten können mehrere Agenten "gleichzeitig" ablaufen.
Idee:
Tick: Zählt durch 0..255
Tack[agM]: Agent wird aufgerufen wenn t=t,

Parameter:
pars,bef,delt,agnt a
Limits:
Bei Aufruf wird nur der inpStack übergeben

Starten:
pars,befnum,delt,ag a       

Restart:
erfolgt wenn Tick=Tack
Bef laden
AGStack-> StackStack für Agenten kopieren



Calc, Memo, Parameter
Ein inp-Stack(20) und 21 Memo-Register dienen zur Speicherung von Werten oder Übergabe von Parametern
,	push inp
+	inp <- pop + inp
-  	inp <- pop - inp 
*	
/
|
&
~	swap inp und inpsw 
>	memo[inp] <- pop
<	inp <- memo[inp]

Beispiel:
3,1>  	speichere 3 in memo[1]
5<		setze inp auf memo[5]
,7+		erhöhe inp um 7
~0,~-	inp = -inp
0,4-	inp auf -4
0+		pop inp
3,2,22x rufe Ablauf 22 params 2 3
		gerufener: 0+ .. inp ist 2 .. 0+ für3
		
Schleifen im Ablauf sind definiert durch startwert, increment und endewert 
U		 starte eine Schleife  (for) mit end, inc vom Stack, inp ist Anfangswert 
u		 neuer Wert errechnen, wenn Wert < Endewert springe zum Befehl nach U mit inp diesen Wert

inc, end, start U ... u
Beispiel:
5DlTtdu
z1,9,0Uclu	Lösche Leds dann setze LED 0 auf color 0, LED 1 auf color 1 usw bis LED 9

6,33x	rufe Ablauf 33, 6 sei Anfangswert für Schleife 4,24,6
		gerufener: 0+~4,24,~U ... u
Schleifen können max 6 geschachtelt sein 		


Zeitsteuerung über Ticks, eingestellt sind 40ms pro Tick (tickTim) d.h. 25 Updates / sec
LEDs werden refreshed
T setze tickTim auf inp



Überblick Moves:
Von/Nach:   Array  Pix		Color   Memo	inp
Array			 L				D
Pix			l				 C				RGB
Color				 c
Memo		d
inp					rgb				>
Analog		 		 a


Fading benutzt memos 10 bis 21 für Parameter für g,r,b
rndMin  10	14	18
rndMax	11	15	19
valMin	12	16	20
valMax	13	17	21


"Schreiben" einzelne Buchstaben sind in Bef


falls rndMin==rndMax 

Beispiel:
4,19,10U~ 30,5,4,0,4-, 1,~,~3+,~U>uu  setze alle 3 Farben auf -4 4 5 30

Muster einzelne pix:
vorher setzen ticks, inp first, rgb pix

colors define	 	10     0 leer, 1 rot, 2 orange .. 7 weiss
colors show      	11	

Orbit links  		21		Höhe auf stack farbe pix speed 3,9>
Spirale links		22		0,21x1,21x2,21x3,21x
Orbit rechts 		23  	Höhe auf stack(23,22,21,20) 
Spirale rechts		24		23,23x22,23x21,23x20,23x
Ring				25		0+~4,23,~Ulu
Balken 	
					31		push  Balken (4 leds) ab inp
					32		Balken ab pop in pix
							0+l#l#l#l
					33		6 Balken c0 bis 5
							0~4,23,0U~c,1+~,32xu
					34      rotiere Ring rechts (Höhe 0..3 von stack)
							0+,~0+L9C4,23,4,~+UL,4-lu,9c4-l
					35 		rotiere Balken rechts speed t
							1,3,0TU,34xut0j
Explosion
Ring
Random color change

https://www.tweaking4all.com/hardware/arduino/adruino-led-strip-effects/
https://adrianotiger.github.io/Neopixel-Effect-Generator/
https://www.instructables.com/id/NeoPixel-Pattern-Programmer/
